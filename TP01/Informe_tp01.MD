# Trabajo Pr√°ctico N¬∫1: Rendimiento - Sistemas de Computaci√≥n

## **1Ô∏è‚É£ Objetivo**

El objetivo de este trabajo pr√°ctico es aplicar conocimientos sobre performance y rendimiento de los computadores en situaciones pr√°cticas. Se busca:

  **1.** Evaluar y seleccionar benchmarks apropiados para diferentes tareas computacionales, con √©nfasis en aquellos relevantes para actividades diarias.

  **2.** Analizar el rendimiento de diferentes procesadores en tareas espec√≠ficas como la compilaci√≥n del kernel de Linux.

  **3.** Medir el rendimiento de c√≥digo propio en una ESP32, variando la frecuencia de reloj y observando su impacto en el rendimiento.

  **4.** Profiling y an√°lisis de rendimiento del c√≥digo. 

---

## **2Ô∏è‚É£ Ejercicio 1: Benchmarks**

### **üîπ 2.1 Lista de benchmarks √∫tiles**

A continuaci√≥n, se detallan algunos benchmarks relevantes seg√∫n distintos tipos de pruebas:

- **CPU:**
  - SPEC CPU
  - Geekbench
  - Cinebench
  - Phoronix Test Suite

- **Memoria:**
  - STREAM
  - Memtest86

- **Almacenamiento (Discos):**
  - CrystalDiskMark
  - fio

- **Compilaci√≥n de c√≥digo:**
  - Phoronix Test Suite - Build Kernel

- **Gaming y gr√°ficos:**
  - 3DMark
  - Unigine Superposition

- **IA y c√°lculo cient√≠fico:**
  - TensorFlow Benchmark
  - LINPACK

### **üîπ 2.2 Tareas diarias y benchmarks correspondientes**

| **Tarea**                   | **Benchmark recomendado**        |
|-----------------------------|---------------------------------|
| Compilaci√≥n de c√≥digo       | Phoronix Test Suite - Build Kernel |
| Desarrollo de software      | SPEC CPU, Geekbench            |
| An√°lisis de datos           | LINPACK, TensorFlow Benchmark  |
| Edici√≥n de video            | Cinebench, 3DMark              |
| Juegos                      | 3DMark, Unigine Superposition  |
| Uso general (navegaci√≥n) | Geekbench, PCMark       |

---

## **3Ô∏è‚É£ Ejercicio 2: Evaluaci√≥n del rendimiento de diferentes procesadores en la compilaci√≥n del kernel de Linux**

### **üîπ 3.1 Rendimiento en la compilaci√≥n del kernel de Linux**

Se evaluar√° el rendimiento de los siguientes procesadores en la compilaci√≥n del kernel de Linux:

- **Intel Core i5-13600K**
- **AMD Ryzen 9 5900X 12-Core**
- **AMD Ryzen 9 7950X 16-Core**

se utiliza la informaci√≥n de OpenBenchmarking para comparar su desempe√±o en la tarea de compilar el kernel de Linux mediante la prueba Timed Linux Kernel Compilation (build-linux-kernel-1.15.0).

### **üîπ 3.2 Datos de Benchmarking**

De acuerdo con los resultados p√∫blicos obtenidos en OpenBenchmarking para la configuraci√≥n "Build: defconfig" del test, se resumen los siguientes tiempos promedio de compilaci√≥n (valores extra√≠dos de la tabla de resultados):

*AMD Ryzen 9 7950X 16-Core:*
Tiempo promedio ‚âà 53 ¬± 3 segundos

*AMD Ryzen 9 5900X 12-Core:*
Tiempo promedio ‚âà 97 ¬± 6 segundos

*Intel Core i5-13600K:*
Tiempo promedio ‚âà 83 ¬± 3 segundos

### **üîπ 3.3 C√°lculo del Speedup**
El **speedup** es una m√©trica clave para evaluar el incremento en el rendimiento de un sistema tras una optimizaci√≥n o al compararlo con otro. En el contexto de la compilaci√≥n del kernel de Linux, el **speedup** indica cu√°nto m√°s r√°pido es un procesador en comparaci√≥n con otro. Se calcula dividiendo el tiempo de ejecuci√≥n en la CPU m√°s lenta por el tiempo en la CPU m√°s r√°pida. Esta medida es fundamental para analizar la eficiencia de sistemas que operan en entornos de alto rendimiento

Utilizando la f√≥rmula:

$Speedup = \frac{Tiempo\ en\ CPU\ m√°s\ lenta}{Tiempo\ en\ CPU\ m√°s\ r√°pida}$

- **Comparacion AMD Ryzen 9 7950X vs AMD Ryzen 9 5900X:**

    $Speedup ‚âà \frac{97}{53} ‚âà 1.83$

Esto indica que el *Ryzen 9 7950x* es aproximadamente 83% m√°s r√°pido en la compilaci√≥n del kernel que el *Ryzen 9 5900X*.

- **Comparaci√≥n AMD Ryzen 9 7950X vs Intel Core i5-13600K:**

    $Speedup ‚âà \frac{83}{53} ‚âà 1.57$

Es decir, *el Ryzen 9 7950X* es cerca de un 57% m√°s r√°pido que el *i5-13600K*.

- **Comparaci√≥n Intel Core i5-13600K vs AMD Ryzen 9 5900X:**

    $Speedup ‚âà \frac{97}{83} ‚âà 1.17$

El *i5-13600K* resulta alrededor de un 17% m√°s r√°pido que el *Ryzen 9 5900X*.


El **speedup** se expresa como un cociente, pero es √∫til traducirlo a un porcentaje para interpretar de forma m√°s intuitiva la mejora en el rendimiento. 

### **üîπ 3.4 An√°lisis y Conclusiones**

- **Rendimiento:**
Los datos indican que el AMD Ryzen 9 7950X 16-Core es el m√°s r√°pido en la tarea de compilaci√≥n del kernel de Linux, lo que sugiere un uso m√°s eficiente de sus 16 n√∫cleos y mejoras arquitect√≥nicas respecto a sus competidores.

- **Eficiencia en el Uso de N√∫cleos:**
Aunque el Ryzen 9 5900X tiene 12 n√∫cleos y el i5-13600K incluso menos, la diferencia en la arquitectura y la optimizaci√≥n del paralelismo se traduce en tiempos de compilaci√≥n m√°s largos en comparaci√≥n con el 7950X.

- **Consideraciones de Costo y Consumo Energ√©tico:**
 Aunque el Ryzen 9 7950X ofrece el mejor rendimiento, su costo y consumo energ√©tico deben considerarse. El i5-13600K, ligeramente m√°s lento, podr√≠a ser una mejor opci√≥n en la relaci√≥n rendimiento/precio para algunos usuarios.


En resumen, para tareas exigentes como la compilaci√≥n del kernel de Linux, el **AMD Ryzen 9 7950X 16-Core** es la opci√≥n m√°s recomendable, ofreciendo el mayor rendimiento. Sin embargo, la elecci√≥n del procesador tambi√©n debe considerar factores como el costo y el consumo energ√©tico, siendo el **Intel Core i5-13600K** una alternativa intermedia atractiva, y el **AMD Ryzen 9 5900X** una opci√≥n potencial para presupuestos m√°s bajos.

---

## **4Ô∏è‚É£ Ejercicio 3: An√°lisis de Rendimiento en ESP32**

### **üîπ 4.1 Configuraci√≥n del Entorno de Desarrollo**

Se utiliz√≥ la extensi√≥n PlatformIO en VS Code para programar la ESP32, permitiendo un entorno de desarrollo avanzado y flexible. Para ello:

  1.  Se instal√≥ la extensi√≥n PlatformIO en Visual Studio Code.

  2. Se configur√≥ un nuevo proyecto para ESP32, seleccionando la placa espec√≠fica y los par√°metros adecuados.

  3. Se modific√≥ el archivo platformio.ini para definir la frecuencia de la CPU y otras configuraciones relevantes.

<div style="text-align: center;">
    <img src="Imagenes/3-3.jpeg" alt="Descripci√≥n" width="200">
</div>

  4. Se utilizaron las bibliotecas adecuadas, incluyendo la API de Arduino para ESP32, que permite modificar la frecuencia del procesador y realizar mediciones de tiempo. Se emplearon funciones como setCpuFrequencyMhz() para ajustar la frecuencia y millis() para registrar los tiempos de ejecuci√≥n de las operaciones.


### **üîπ 4.2 Carga y Ejecuci√≥n del C√≥digo**

Se realizaron pruebas con frecuencias de 80 MHz y 160 MHz, midiendo el rendimiento de operaciones matem√°ticas con enteros y flotantes. Los resultados obtenidos fueron:

<div style="text-align: center;">
    <img src="Imagenes/3-1.jpeg" alt="Descripci√≥n" width="300">
</div>


<div style="text-align: center;">
    <img src="Imagenes/3-2.jpeg" alt="Descripci√≥n" width="300">
</div>


### **üîπ 4.3 Tabla de Resultados**

| Frecuencia (MHz) | Iteraciones | Tiempo suma enteros (ms) | Tiempo suma flotantes (ms) | Tiempo total (ms) | Rendimiento (1/s) |
|------------------|-------------|--------------------------|----------------------------|-------------------|-------------------|
| 80 MHz           | 35.000.000  | 4981                     | 5887                       | 10868             | 0.000092          |
| 160 MHz          | 35.000.000  | 2447                     | 2892                       | 5339              | 0.000187          |


### **üîπ 4.4 C√°lculo de SpeedUp**
1. C√°lculo del rendimiento (1/s)

    Primero, calculamos el rendimiento para cada frecuencia usando la f√≥rmula: Œ∑prog = 1 / Tprog

    - Para **80 MHz**:
      
      Œ∑prog = 1 / 10868 ms ‚âà 0.000092 s‚Åª¬π

    - Para **160 MHz**:

      Œ∑prog = 1 / 5339 ms ‚âà 0.000187 s‚Åª¬π
2. C√°lculo del Speedup

    El **speedup** se calcula ahora como la relaci√≥n entre el rendimiento en la frecuencia m√°s alta (160 MHz) y el rendimiento en la frecuencia m√°s baja (80 MHz).

      $Speedup = \frac{Œ∑prog_{160}}{Œ∑prog_{80}} = \frac{0.000187}{0.000092} \approx 2.03$

Este valor indica que, al duplicar la frecuencia de la CPU de **80 MHz** a **160 MHz**, el rendimiento mejora aproximadamente **2.03 veces**. Es decir, el sistema es **m√°s de dos veces m√°s r√°pido** a 160 MHz en comparaci√≥n con 80 MHz.

### **üîπ 4.5 Conclusiones Finales**

El **speedup** de **2.03** es bastante cercano a la duplicaci√≥n esperada del rendimiento debido al aumento de la frecuencia de la CPU. Esto sugiere que, para esta tarea espec√≠fica (sumas de enteros y flotantes), el rendimiento sigue una relaci√≥n casi lineal con la frecuencia de la CPU. Sin embargo, este comportamiento puede variar dependiendo de la naturaleza de las tareas, ya que en algunas situaciones el rendimiento puede no escalar de manera tan lineal debido a otros factores como la latencia de memoria, la arquitectura del procesador y las optimizaciones del compilador.


## **5Ô∏è‚É£ Ejercicio 4: Profiling y an√°lisis de rendimiento del c√≥digo**

Se siguieron la serie de instrucciones para medir los tiempos de ejecucion de las distintas funciones proporcionadas y se determin√≥ qu√© partes del c√≥digo consumen m√°s recursos computacionales.

Se adjuntan las capturas realizadas de uno de los participantes del equipo que tiene las siguientes especificaciones: 

*Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz 2.90 GHz - SSD 256GB   - RAM 8GB*

<img src="Imagenes/4_1.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-2.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-3.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-4.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-5.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-6.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-7.jpeg" alt="Descripci√≥n" width="300">

<img src="Imagenes/4-8.jpeg" alt="Descripci√≥n" width="500">

<img src="Imagenes/4-9.jpeg" alt="Descripci√≥n" width="500">


### **üîπTabla de resultados**
Si comparamos el rendimiento de todo el equipo:

*Intel(R) Core(TM) i3-7020U CPU @ 2.30GHz - SSD 240GB - RAM 6GB*

*Intel(R) Core(TM) i5-7300U CPU @ 2.60GHz - SSD 256GB - RAM 8GB*

*Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz 2.90 GHz - SSD 256GB   - RAM 8GB*

| CPU | Almacenamiento | RAM | Tiempo Total (s) | Tiempo en `main` (s) | Tiempo en `func1` (s) | Tiempo en `func2` (s) | Tiempo en `newfunc` (s) | GCC Version |
|------------------------------|-------------|-----|---------------|----------------|----------------|----------------|----------------|----------------|
| **Intel Core i3-7020U @ 2.30GHz** | SSD 240GB  | 6GB | 31.89 | 0.06 | 10.80 | 9.95 | 11.08 |  13.3.0 |
| **Intel Core i5-7300U @ 2.60GHz** | SSD 256GB  | 8GB | 20.99 | 0.05 | 7.18  | 6.56 | 7.20  |  13.3.0 |
| **Intel Core i7-7500U @ 2.70GHz** | SSD 256GB  | 8GB | 24.17 | 0.02 | 8.53  | 7.73 | 7.99  |  13.3.0 |


El an√°lisis de Time Profiling muestra diferencias en el tiempo de ejecuci√≥n del programa seg√∫n la configuraci√≥n del hardware. En general, el procesador Intel Core i5-7300U present√≥ el mejor desempe√±o con un tiempo total de 20.99s, mientras que el Intel Core i3-7020U tuvo el peor rendimiento con 31.89s, lo cual era esperado debido a sus especificaciones m√°s bajas.

A pesar de que el Intel Core i7-7500U es te√≥ricamente m√°s potente, su tiempo total de 24.17s no refleja una ventaja significativa sobre el i5. Posiblemente debido a la falta de una instalaci√≥n nativa de Linux.




----
